<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>UIImage+ImageEffects模糊滤镜理解 | Wootau's blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">UIImage+ImageEffects模糊滤镜理解</h1><a id="logo" href="/.">Wootau's blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">UIImage+ImageEffects模糊滤镜理解</h1><div class="post-meta">Aug 20, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>最近学习到模糊效果，遇到了 UIImage+ImageEffects 分类，通过阅读官方文档，初步理解了原理，在此整理一下。效果如下：<br><img src="http://ob9hppsg4.bkt.clouddn.com/Blur.png" alt="UIImage+ImageEffects">  </p>
<h2 id="UIBlurEffect"><a href="#UIBlurEffect" class="headerlink" title="UIBlurEffect"></a>UIBlurEffect</h2><p>提到模糊效果，首先不得不提 iOS8 SDK 中自带的 UIBlurEffect 类和 UIVisualEffectView 类。使添加模糊滤镜过程大大简化，不再需要截屏获取UIImage，也不需要添加额外分类：<br><small>注：不能设置<code>effectView</code>的<code>alpha</code>的属性，否则会报错。</small>    </p>
<blockquote>
<p>UIBlurEffect * blurEffect = [UIBlurEffect effectWithStyle: UIBlurEffectStyleLight];<br>UIVisualEffectView * effectView = [[UIVisualEffectView alloc] initWithEffect: blurEffect];</p>
<p>effectView.frame = imageView.bounds;<br>[imageView addSubview: effectView];  </p>
</blockquote>
<p>通过以上简单几行代码，即可对 imageView 添加模糊效果：<br><img src="http://ob9hppsg4.bkt.clouddn.com/UIBlurEffect.png" alt="UIBlurEffect">  </p>
<h2 id="UIImage-ImageEffects"><a href="#UIImage-ImageEffects" class="headerlink" title="UIImage+ImageEffects"></a>UIImage+ImageEffects</h2><p>与 UIBezierPath 类似，UIBlurEffect 封装地很好，功能却有限，难以实现复杂要求的自定义效果。UIImage+ImageEffects 通过两个主要参数设置滤镜的模糊半径与饱和度，在灵活性上远超iOS自带的 UIBlurEffect 类。  </p>
<p><strong>UIImage+ImageEffects 的核心方法：</strong>    </p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- <span class="params">(UIImage *)</span>applyBlurWithRadius:<span class="params">(CGFloat)</span>blurRadius</div><div class="line">                       tintColor:<span class="params">(UIColor *)</span>tintColor</div><div class="line">           saturationDeltaFactor:<span class="params">(CGFloat)</span>saturationDeltaFactor</div><div class="line">                       maskImage:<span class="params">(UIImage *)</span>maskImage;</div></pre></td></tr></table></figure>
<p><strong>参数：</strong>  </p>
<ul>
<li>(CGFloat)blurRadius 模糊半径，起始值为 0.3，数值越大，图片越模糊；  </li>
<li>(UIColor *)tintColor 传入的颜色滤镜，若tintColor有传值，则简单用其作为填充色fill模糊运算后的图形上下文；  </li>
<li>(CGFloat)saturationDeltaFactor 饱和度偏移值，blurRadius 不为 0 才有效果，平衡值为1.0f。(0 -&gt; 1.0) 削减饱和度，(1.0 -&gt; 137.0) 增加饱和度（我测试中137以上值发生了颜色溢出，实际上10.0已经足够鲜艳了)；  </li>
<li>(UIImage *)maskImage 传入的裁剪区域，maskImage 仅 alpha 值作用于裁剪区域，决定裁剪区的透明度。  </li>
</ul>
<p><strong>返回值：</strong><br>该方法为 UIImage 的分类方法，消息接收方为<code>sourceImage</code>，返回修改后的<code>outputImage</code>，该方法不会修改原图片。  </p>
<hr>
<h2 id="方法简析"><a href="#方法简析" class="headerlink" title="方法简析"></a>方法简析</h2><blockquote>
<p>applyBlurWithRadius:tintColor:saturationDeltaFactor:maskImage:  </p>
</blockquote>
<h3 id="判断参数是否满足要求："><a href="#判断参数是否满足要求：" class="headerlink" title="判断参数是否满足要求："></a>判断参数是否满足要求：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.size.width &lt; <span class="number">1</span> || <span class="keyword">self</span>.size.height &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span> (<span class="string">@"*** error: invalid size: (%.2f x %.2f). Both dimensions must be &gt;= 1: %@"</span>, <span class="keyword">self</span>.size.width, <span class="keyword">self</span>.size.height, <span class="keyword">self</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.CGImage) &#123;</div><div class="line">        <span class="built_in">NSLog</span> (<span class="string">@"*** error: image must be backed by a CGImage: %@"</span>, <span class="keyword">self</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (maskImage &amp;&amp; !maskImage.CGImage) &#123;</div><div class="line">        <span class="built_in">NSLog</span> (<span class="string">@"*** error: maskImage must be backed by a CGImage: %@"</span>, maskImage);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果自身长宽小于1，没有模糊的意义，return；  </li>
<li>如果自身无CGImage，代表图片无可模糊内容，return；  </li>
<li>如果裁剪区域maskImage有传参却无CGImage，<code>CGContextClipToMask</code>方法参数为nil，裁剪区域为空，return。  </li>
</ul>
<h3 id="创建vImage输入-amp-输出缓存"><a href="#创建vImage输入-amp-输出缓存" class="headerlink" title="创建vImage输入&amp;输出缓存:"></a>创建vImage输入&amp;输出缓存:</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, [[<span class="built_in">UIScreen</span> mainScreen] scale]);</div><div class="line"><span class="built_in">CGContextRef</span> effectInContext = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line"><span class="built_in">CGContextScaleCTM</span>(effectInContext, <span class="number">1.0</span>, <span class="number">-1.0</span>);</div><div class="line"><span class="built_in">CGContextTranslateCTM</span>(effectInContext, <span class="number">0</span>, -<span class="keyword">self</span>.size.height);</div><div class="line"><span class="built_in">CGContextDrawImage</span>(effectInContext, imageRect, <span class="keyword">self</span>.CGImage);</div><div class="line"></div><div class="line">vImage_Buffer effectInBuffer;</div><div class="line">effectInBuffer.data     = <span class="built_in">CGBitmapContextGetData</span>(effectInContext);</div><div class="line">effectInBuffer.width    = <span class="built_in">CGBitmapContextGetWidth</span>(effectInContext);</div><div class="line">effectInBuffer.height   = <span class="built_in">CGBitmapContextGetHeight</span>(effectInContext);</div><div class="line">effectInBuffer.rowBytes = <span class="built_in">CGBitmapContextGetBytesPerRow</span>(effectInContext);</div><div class="line">    </div><div class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.size, <span class="literal">NO</span>, [[<span class="built_in">UIScreen</span> mainScreen] scale]);</div><div class="line"><span class="built_in">CGContextRef</span> effectOutContext = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">vImage_Buffer effectOutBuffer;</div><div class="line">effectOutBuffer.data     = <span class="built_in">CGBitmapContextGetData</span>(effectOutContext);</div><div class="line">effectOutBuffer.width    = <span class="built_in">CGBitmapContextGetWidth</span>(effectOutContext);</div><div class="line">effectOutBuffer.height   = <span class="built_in">CGBitmapContextGetHeight</span>(effectOutContext);</div><div class="line">effectOutBuffer.rowBytes = <span class="built_in">CGBitmapContextGetBytesPerRow</span>(effectOutContext);</div></pre></td></tr></table></figure>
<p>首先翻转图形上下文，将 self 绘制于上下文中，接下来创建两个 vImage_Buffer 作为输入&amp;输出缓存，effectInBuffer 与 effectOutBuffer 均保存了上下文中的图片内容。  </p>
<h3 id="根据传入半径卷积模糊图像"><a href="#根据传入半径卷积模糊图像" class="headerlink" title="根据传入半径卷积模糊图像:"></a>根据传入半径卷积模糊图像:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">if (hasBlur) &#123;</div><div class="line">    CGFloat inputRadius = blurRadius * [[UIScreen mainScreen] scale];</div><div class="line">    NSUInteger radius = floor(inputRadius * <span class="number">3.</span> * sqrt(<span class="number">2</span> * M_PI) / <span class="number">4</span> + <span class="number">0.5</span>);</div><div class="line">    </div><div class="line">    if (radius % <span class="number">2</span> != <span class="number">1</span>) &#123;</div><div class="line">        radius += <span class="number">1</span>; </div><div class="line">    &#125;</div><div class="line">    vImageBoxConvolve_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, NULL, <span class="number">0</span>, <span class="number">0</span>, radius, radius, <span class="number">0</span>, kvImageEdgeExtend);</div><div class="line">    vImageBoxConvolve_ARGB8888(&amp;effectOutBuffer, &amp;effectInBuffer, NULL, <span class="number">0</span>, <span class="number">0</span>, radius, radius, <span class="number">0</span>, kvImageEdgeExtend);</div><div class="line">    vImageBoxConvolve_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, NULL, <span class="number">0</span>, <span class="number">0</span>, radius, radius, <span class="number">0</span>, kvImageEdgeExtend);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果存在传入模糊度<br><code>NSUInteger radius = floor(inputRadius * 3. * sqrt(2 * M_PI) / 4 + 0.5)</code><br>通过传入值计算实际使用的半径，该式确保模糊半径从0.3开始输出值大于2。  </p>
<p><strong>模糊算法的核心函数:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function">vImage_Error <span class="title">vImageBoxConvolve_ARGB8888</span> <span class="params">(</span></span></div><div class="line">   <span class="keyword">const</span> vImage_Buffer *src,           <span class="comment">//输入缓存</span></div><div class="line">   <span class="keyword">const</span> vImage_Buffer *dest,          <span class="comment">//输出缓存</span></div><div class="line">   <span class="keyword">void</span> *tempBuffer,                   <span class="comment">//函数运行时建立的临时缓存，传入NULL则函数负责创建与释放</span></div><div class="line">   vImagePixelCount srcOffsetToROI_X,  <span class="comment">//以像素为单位，水平方向相对于原图片计算区左上角的偏移量</span></div><div class="line">   vImagePixelCount srcOffsetToROI_Y,  <span class="comment">//以像素为单位，垂直方向相对于原图片计算区左上角的偏移量</span></div><div class="line">   <span class="keyword">uint32_t</span> kernel_height,             <span class="comment">//内核高度，必须为奇数</span></div><div class="line">   <span class="keyword">uint32_t</span> kernel_width,              <span class="comment">//内核宽度，必须为奇数</span></div><div class="line">   <span class="keyword">const</span> Pixel_8888 backgroundColor,   <span class="comment">//填充颜色，kvImageBackgroundColorFill模式下才有效</span></div><div class="line">   vImage_Flags flags                  <span class="comment">//运算模式</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>该函数属于vImage Convolution Reference。最重要的参数为kernel_height，kernel_width，它们决定了卷积所需的内核大小。  </p>
<p><strong>vImage Convolution Reference类函数运算遵循以下公式：</strong>  </p>
<ul>
<li><p>For floating-point formats: </p>
<div align="center"><br><img src="http://ob9hppsg4.bkt.clouddn.com/float_kernel.jpg" alt=""><br></div>
</li>
<li><p>For integer formats:</p>
<div align="center"><br><img src="http://ob9hppsg4.bkt.clouddn.com/integer_kernel.jpg" alt=""><br></div>

</li>
</ul>
<p><small>浮点数类型函数标准矩阵卷积为1.0，整数类型函数除以M * N为1。<br>vImageBoxConvolve_ARGB8888 函数拥有默认内核，调用者只需要提供长宽，该内核保证卷积运算结果为M * N范围内各点的平均（平滑）值。</small>  </p>
<p>vImageBoxConvolve_ARGB8888 函数属于整数类型，遵循第二个公式，卷积运算后除以内核大小M * N，得到目标值;   </p>
<p><strong>图像卷积和运算公式如下：</strong></p>
<div align="center"><br><img src="http://ob9hppsg4.bkt.clouddn.com/201105192042109313.png" alt=""><br></div>

<ul>
<li>g(i, j) 位于矩阵中心，代表M * N矩阵内输入图片与内核的卷积和； </li>
<li>f(k, l) 为输入图片以 (i, j) 为中心，M * N矩阵范围内的各个点；  </li>
<li>h(i - k，j - l) 由M * N内核点 h(k, l) 绕中心旋转180度得到；  </li>
<li>输入图像与内核对应点相乘求和，最后再除以M * N，得到最终 g(i, j) 点的值。  </li>
</ul>
<p>简单地理解，一张大小为4 * 4的图片，内核大小为3 * 3范围建立坐标系，中点g(i, j)对应坐标原点(0, 0)，将内核绕中心旋转180°，如图所示：<br>g(0, 0) = (f(-1,1) * h(1,-1) + f(0,1) * h(0,-1) + … + f(0,-1) * h(0,1) + f(1,-1) * h(-1,1)) / (3 * 3) ;</p>
<div align="center"><br><img src="http://ob9hppsg4.bkt.clouddn.com/123.jpg" alt=""><br></div>

<p><small>对于单个RGB图像像素，共有red，green，blue，alpha 4个属性，上述公式需要分别计算四值，最终得出目标像素值</small>  </p>
<p><strong>图像边缘处理</strong><br>当目标点处于边缘时，内核的一部分将处于图像外，如图：</p>
<div align="center"><br><img src="http://ob9hppsg4.bkt.clouddn.com/1233.jpg" alt=""><br></div>

<p>由于输入图片在内核超出位置无数据，所以需要处理，一般有两种方式。  </p>
<ul>
<li>常数填充，默认填充值为 0，造成结果为图片边缘黑边；</li>
<li>复制图片边缘数据，如图所示，f(-1,1) 值被 f(-1,0) 取代。  </li>
</ul>
<p>鉴于本例中为模糊函数，本身是求均值，所以可认为函数采用第二种策略。  </p>
<p>函数使内核遍历传入图像内每个点，求出每个点卷积后的均值作为输出图像目标点。将遍历过程看作一个函数，与原函数对比明显更加平滑（每个相邻点值更加接近），作用于图片则呈现出模糊效果。该方法调用了三次 vImageBoxConvolve_ARGB8888 函数，原因是多次运算可以使模糊效果更加自然。  </p>
<h3 id="计算饱和度"><a href="#计算饱和度" class="headerlink" title="计算饱和度:"></a>计算饱和度:</h3><p>saturationDeltaFactor = 0:</p>
<div align="center"><br><img src="http://ob9hppsg4.bkt.clouddn.com/0.png" alt=""><br></div><br>saturationDeltaFactor = 2.0<br><div align="center"><br><img src="http://ob9hppsg4.bkt.clouddn.com/2.png" alt=""><br></div>

<p>首先建立色彩矩阵，将矩阵值转化为 [0, 255] 内的整数，调用 vImageMatrixMultiply_ARGB8888 函数，传入输入&amp;输出缓存，色彩矩阵，除数。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">if (hasSaturationChange) &#123;</div><div class="line">    CGFloat s = saturationDeltaFactor;</div><div class="line">    CGFloat floatingPointSaturationMatrix[] = &#123;</div><div class="line">        <span class="number">0.0722</span> + <span class="number">0.9278</span> * s,  <span class="number">0.0722</span> - <span class="number">0.0722</span> * s,  <span class="number">0.0722</span> - <span class="number">0.0722</span> * s,  <span class="number">0</span>,</div><div class="line">        <span class="number">0.7152</span> - <span class="number">0.7152</span> * s,  <span class="number">0.7152</span> + <span class="number">0.2848</span> * s,  <span class="number">0.7152</span> - <span class="number">0.7152</span> * s,  <span class="number">0</span>,</div><div class="line">        <span class="number">0.2126</span> - <span class="number">0.2126</span> * s,  <span class="number">0.2126</span> - <span class="number">0.2126</span> * s,  <span class="number">0.2126</span> + <span class="number">0.7873</span> * s,  <span class="number">0</span>,</div><div class="line">                          <span class="number">0</span>,                    <span class="number">0</span>,                    <span class="number">0</span>,  <span class="number">1</span>,</div><div class="line">    &#125;;</div><div class="line">    const int32_t divisor = <span class="number">256</span>;</div><div class="line">    NSUInteger matrixSize = sizeof(floatingPointSaturationMatrix)/sizeof(floatingPointSaturationMatrix[<span class="number">0</span>]);</div><div class="line">    int16_t saturationMatrix[matrixSize];</div><div class="line">    for (NSUInteger i = <span class="number">0</span>; i &lt; matrixSize; ++i) &#123;</div><div class="line">        saturationMatrix[i] = (int16_t)roundf(floatingPointSaturationMatrix[i] * divisor);</div><div class="line">    &#125;</div><div class="line">    if (hasBlur) &#123;</div><div class="line">        vImageMatrixMultiply_ARGB8888(&amp;effectOutBuffer, &amp;effectInBuffer, saturationMatrix, <span class="number">256</span>, NULL, NULL, kvImageNoFlags);</div><div class="line">        effectImageBuffersAreSwapped = YES;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        vImageMatrixMultiply_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, saturationMatrix, <span class="number">256</span>, NULL, NULL, kvImageNoFlags);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>饱和度算法的核心函数：</strong>   </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">vImage_Error <span class="title">vImageMatrixMultiply_ARGB8888</span> <span class="params">(</span></span></div><div class="line">   <span class="keyword">const</span> vImage_Buffer *src,    <span class="comment">//输入缓存</span></div><div class="line">   <span class="keyword">const</span> vImage_Buffer *dest,   <span class="comment">//输出缓存</span></div><div class="line">   <span class="keyword">const</span> <span class="keyword">int16_t</span> matrix[<span class="number">16</span>],    <span class="comment">//色彩矩阵</span></div><div class="line">   <span class="keyword">int32_t</span> divisor,             <span class="comment">//除数，用于控制结果范围</span></div><div class="line">   <span class="keyword">const</span> <span class="keyword">int16_t</span> *pre_bias,     <span class="comment">//输入图像预处理，一般为NULL</span></div><div class="line">   <span class="keyword">const</span> <span class="keyword">int32_t</span> *post_bias,    <span class="comment">//输出图像预处理，一般为NULL</span></div><div class="line">   vImage_Flags flags           <span class="comment">//固定为0值</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>该函数属于vImage Transform Reference，该类函数与vImage Convolution Reference类函数不同之处在于<strong>“目标点值的计算不依据周围相邻点值”</strong>，而是直接将原点值与调用者提供的色彩矩阵 matrix 相乘得到目标点值，该函数影响每个点的色彩。  </p>
<p><strong>vImageMatrixMultiply_ARGB8888 函数的色彩标准矩阵结构：</strong>  </p>
<div align="center"><br><img src="http://ob9hppsg4.bkt.clouddn.com/matrxinew.png" alt="matrix"><br></div><br>[X<sub>1</sub>，X<sub>16</sub>] 为调用者提供的色彩矩阵，其中A轴X<sub>4</sub>，X<sub>8</sub>，X<sub>12</sub>应填入 0；<br>X<sub>13</sub>，X<sub>14</sub>，X<sub>15</sub>分别为B，G，R色彩的蒙板，范围为[0，1]，设置为相同值可以提高亮度；<br><small>测试中X<sub>4</sub>，X<sub>8</sub>，X<sub>12</sub>于X<sub>16</sub>小于1时可以发挥部分alpha值的作用，效果差且不可控，故应将其视作填充坐标，而将透明度交由X<sub>16</sub>控制。</small><br><br>设原值为 (R, G, B, A)，目标值为 (R<sub>n</sub>，G<sub>n</sub>，B<sub>n</sub>，A<sub>n</sub>)，其余坐标作用如下：<br><br>B<sub>n</sub> = X<sub>1</sub> * B + X<sub>5</sub> * G + X<sub>9</sub> * R + (1 - (X<sub>1</sub> * B + X<sub>5</sub> * G + X<sub>9</sub> * R)) * X<sub>13</sub>；<br>G<sub>n</sub> = X<sub>2</sub> * B + X<sub>6</sub> * G + X<sub>10</sub> * R + (1 - (X<sub>2</sub> * B + X<sub>6</sub> * G + X<sub>10</sub> * R)) * X<sub>14</sub>；<br>R<sub>n</sub> = X<sub>3</sub> * B + X<sub>7</sub> * G + X<sub>11</sub> * R + (1 - (X<sub>3</sub> * B + X<sub>7</sub> * G + X<sub>11</sub> * R)) * X<sub>15</sub>；<br>A<sub>n</sub> = X<sub>16</sub> * A；<br><small>以上是理想状况下的公式，需满足 (R<sub>n</sub>&lt;=1, G<sub>n</sub>&lt;=1, B<sub>n</sub>&lt;=1)，颜色溢出不在讨论范围内。<br>原函数将原RGB值先转化为255范围内整数，计算后再除去256得到目标RGB值，可以认为RGB值始终在 [0，1) 范围内</small><br><br>不考虑透明度与a行蒙板，则：<br><br>B<sub>n</sub> = X<sub>1</sub> * B + X<sub>5</sub> * G + X<sub>9</sub> * R；<br>G<sub>n</sub> = X<sub>2</sub> * B + X<sub>6</sub> * G + X<sub>10</sub> * R；<br>R<sub>n</sub> = X<sub>3</sub> * B + X<sub>7</sub> * G + X<sub>11</sub> * R；<br><br>显然，<strong>新的色值为该列前三个坐标值与原色彩B，G，R值对应的乘积和。</strong>例如坐标(B，g)，B<sub>n</sub>的该坐标分量为X<sub>5</sub> * G，即用原G值计算新B值。到这里也很好理解左侧矩阵为何将1填入(B，b)，(G，g)，(R，r)，只有这三个坐标新旧色彩不会跨通道计算，因而乘积不变。<br><br>为了计算饱和度，需要为函数提供饱和度矩阵，UIImage+ImageEffects 中提供的矩阵利用了以下灰度公式：<br><br><img src="http://ob9hppsg4.bkt.clouddn.com/e.jpg" alt=""><br><br>饱和度矩阵：<br><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CGFloat floatingPointSaturationMatrix[] = &#123;</div><div class="line">    <span class="number">0.0722</span> + <span class="number">0.9278</span> * s,  <span class="number">0.0722</span> - <span class="number">0.0722</span> * s,  <span class="number">0.0722</span> - <span class="number">0.0722</span> * s,  <span class="number">0</span>,</div><div class="line">    <span class="number">0.7152</span> - <span class="number">0.7152</span> * s,  <span class="number">0.7152</span> + <span class="number">0.2848</span> * s,  <span class="number">0.7152</span> - <span class="number">0.7152</span> * s,  <span class="number">0</span>,</div><div class="line">    <span class="number">0.2126</span> - <span class="number">0.2126</span> * s,  <span class="number">0.2126</span> - <span class="number">0.2126</span> * s,  <span class="number">0.2126</span> + <span class="number">0.7873</span> * s,  <span class="number">0</span>,</div><div class="line">                      <span class="number">0</span>,                    <span class="number">0</span>,                    <span class="number">0</span>,  <span class="number">1</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure><br><br>设饱和度为0，得到简化后的矩阵：<br><div align="center"><br><strong>| 0.0722,　0.0722,　0.0722, 　0 |</strong><br><strong>| 0.7152,  　0.7152,  　0.7152,  　0 |</strong><br><strong>| 0.2126,  　0.2126,  　0.2126,  　0 |</strong><br><strong>| 0,　　　　0,　　　　0,　　 　1 |</strong><br></div>

<p>B<sub>n</sub> = 0.0722 * B + 0.7152 * G + 0.2126 * R；<br>G<sub>n</sub> = 0.0722 * B + 0.7152 * G + 0.2126 * R；<br>R<sub>n</sub> = 0.0722 * B + 0.7152 * G + 0.2126 * R；  </p>
<p>此时B<sub>n</sub> = G<sub>n</sub> = R<sub>n</sub> = Gray，图片正好被转化为黑白图像。实际上，只需要 b，g，r 行均相同即可达到B<sub>n</sub> = G<sub>n</sub> = R<sub>n</sub>的效果，但采用灰度公式提供的比例更加自然。  </p>
<p>设饱和度为1.0，得到简化后的矩阵：  </p>
<div align="center"><br><strong>| 1,　　　　0,　　　　0,  　　　0 |</strong><br><strong>| 0,　　　　1,　　　　0,  　　　0 |</strong><br><strong>| 0,　　　　0,　　　　1,  　　　0 |</strong><br><strong>| 0,　　　　0,　　　　0,  　　　1 |</strong><br></div>

<p>B<sub>n</sub> = B；<br>G<sub>n</sub> = G；<br>R<sub>n</sub> = R；  </p>
<p>饱和度偏移为1.0时图片饱和度不变，因而1.0为平衡值。 </p>
<p>回到最初的矩阵中，经化简可得：  </p>
<p>B<sub>n</sub> = 0.0722 * B + 0.7152 * G + 0.2126 * R + (0.9278 * B - 0.7152 * G - 0.2126 * R) * s；<br>G<sub>n</sub> = 0.0722 * B + 0.7152 * G + 0.2126 * R + (0.2848 * G - 0.0722 * B - 0.2126 * R) * s；<br>R<sub>n</sub> = 0.0722 * B + 0.7152 * G + 0.2126 * R + (0.7873 * R - 0.0722 * B - 0.7152 * G) * s；  </p>
<p>每个值均是以 s 为横坐标的一次函数，结合 s 为 0 与 1.0 的情况：  </p>
<ul>
<li>B函数于 [0，1.0] 内经过 (0，Gray)，(1.0，B)，期间B值于 [Gray，B] 间一次变化；  </li>
<li>G函数于 [0，1.0] 内经过 (0，Gray)，(1.0，B)，期间G值于 [Gray，G] 间一次变化；  </li>
<li>R函数于 [0，1.0] 内经过 (0，Gray)，(1.0，B)，期间R值于 [Gray，R] 间一次变化。  </li>
</ul>
<p>类似上一篇文章中的饱和度计算方式，<strong>R，G，B值保持相同的速率比(斜率比)变化，</strong>均能于 s = 0时变为Gray，s = 1.0 时回到原值，达到色相不变而变化饱和度的目的；<br>因为为一次函数，(1.0，∞) 范围内R，G，B值仍与 [0，1.0] 内以相同速率递增｜递减，故增加饱和度同样可以正确实现 (没有规定上限，颜色可能会溢出)。  </p>
<h3 id="设置裁剪区域-amp-颜色蒙板"><a href="#设置裁剪区域-amp-颜色蒙板" class="headerlink" title="设置裁剪区域&amp;颜色蒙板:"></a>设置裁剪区域&amp;颜色蒙板:</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (hasBlur) &#123;</div><div class="line">    <span class="built_in">CGContextSaveGState</span>(outputContext);</div><div class="line">    <span class="keyword">if</span> (maskImage) &#123;</div><div class="line">        <span class="built_in">CGContextClipToMask</span>(outputContext, imageRect, maskImage.CGImage);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CGContextDrawImage</span>(outputContext, imageRect, effectImage.CGImage);</div><div class="line">    <span class="built_in">CGContextRestoreGState</span>(outputContext);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (tintColor) &#123;</div><div class="line">    <span class="built_in">CGContextSaveGState</span>(outputContext);</div><div class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(outputContext, tintColor.CGColor);</div><div class="line">    <span class="built_in">CGContextFillRect</span>(outputContext, imageRect);</div><div class="line">    <span class="built_in">CGContextRestoreGState</span>(outputContext);</div><div class="line">    <span class="built_in">UIImage</span> *outputImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    <span class="keyword">return</span> outputImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现了饱和度运算后，若有传入的maskImage，则用其设置Clip，若有tintColor，则将其设置为颜色蒙板，至此，得到最终输出结果。  </p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/08/20/UIImage-ImageEffects模糊滤镜理解/" data-id="cis5nb2ud0000r3ub6t1h5be4" class="article-share-link">Aktie</a><div class="tags"></div><div class="post-nav"><a href="/2016/08/02/PhotoShop-RGB色相-饱和度-明度函数模拟/" class="next">PhotoShop--RGB色相&amp;饱和度&amp;明度函数模拟</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/08/20/UIImage-ImageEffects模糊滤镜理解/">UIImage+ImageEffects模糊滤镜理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/02/PhotoShop-RGB色相-饱和度-明度函数模拟/">PhotoShop--RGB色相&饱和度&明度函数模拟</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/01/我的第一篇文章/">第一篇博文</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Wootau's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>